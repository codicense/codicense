import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { LockfileParser } from '../src/parsers/lockfile-parser';

describe('Lockfile Parser', () => {
  let testDir: string;

  beforeEach(() => {
    testDir = fs.mkdtempSync(path.join(os.tmpdir(), 'codicense-test-'));
  });

  afterEach(() => {
    fs.rmSync(testDir, { recursive: true, force: true });
  });

  describe('npm lockfile v2', () => {
    it('should parse valid npm lockfile v2', async () => {
      const lockfile = {
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 2,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0',
            license: 'MIT',
            dependencies: {
              lodash: '^4.17.21',
            },
          },
          'node_modules/lodash': {
            version: '4.17.21',
            resolved: 'https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz',
            license: 'MIT',
          },
        },
      };

      fs.writeFileSync(
        path.join(testDir, 'package-lock.json'),
        JSON.stringify(lockfile)
      );

      const result = await LockfileParser.parse(testDir);

      expect(result.name).toBe('test-project');
      expect(result.children.length).toBe(1);
      expect(result.children[0].name).toBe('lodash');
      expect(result.children[0].license).toBe('MIT');
    });

    it('should handle dev dependencies correctly', async () => {
      const lockfile = {
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 2,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0',
            license: 'MIT',
            dependencies: {
              lodash: '^4.17.21',
            },
            devDependencies: {
              jest: '^29.0.0',
            },
          },
          'node_modules/lodash': {
            version: '4.17.21',
            license: 'MIT',
          },
          'node_modules/jest': {
            version: '29.0.0',
            dev: true,
            license: 'MIT',
          },
        },
      };

      fs.writeFileSync(
        path.join(testDir, 'package-lock.json'),
        JSON.stringify(lockfile)
      );

      const result = await LockfileParser.parse(testDir);

      // Should have both dependencies
      expect(result.children.length).toBeGreaterThanOrEqual(1);
      
      // Find jest if present
      const jestPkg = result.children.find((c) => c.name === 'jest');
      if (jestPkg) {
        expect(jestPkg.dev).toBe(true);
      }
    });
  });

  describe('npm lockfile v3', () => {
    it('should parse npm lockfile v3 format', async () => {
      const lockfile = {
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 3,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0',
            license: 'MIT',
            dependencies: {
              express: '^4.18.0',
            },
          },
          'node_modules/express': {
            version: '4.18.2',
            license: 'MIT',
            dependencies: {
              'body-parser': '1.20.1',
            },
          },
          'node_modules/body-parser': {
            version: '1.20.1',
            license: 'MIT',
          },
        },
      };

      fs.writeFileSync(
        path.join(testDir, 'package-lock.json'),
        JSON.stringify(lockfile)
      );

      const result = await LockfileParser.parse(testDir);

      expect(result.name).toBe('test-project');
      expect(result.children.length).toBeGreaterThanOrEqual(1);
    });
  });

  describe('Yarn Classic', () => {
    it('should parse yarn.lock format', async () => {
      const yarnLock = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

lodash@^4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==
`;

      fs.writeFileSync(path.join(testDir, 'yarn.lock'), yarnLock);
      fs.writeFileSync(
        path.join(testDir, 'package.json'),
        JSON.stringify({
          name: 'test-project',
          version: '1.0.0',
          license: 'MIT',
          dependencies: { lodash: '^4.17.21' },
        })
      );

      const result = await LockfileParser.parse(testDir);

      expect(result.name).toBe('test-project');
    });
  });

  describe('Error handling', () => {
    it('should throw error when no lockfile found', async () => {
      await expect(LockfileParser.parse(testDir)).rejects.toThrow();
    });

    it('should handle malformed JSON gracefully', async () => {
      fs.writeFileSync(
        path.join(testDir, 'package-lock.json'),
        'not valid json {'
      );

      await expect(LockfileParser.parse(testDir)).rejects.toThrow();
    });

    it('should handle empty lockfile', async () => {
      fs.writeFileSync(path.join(testDir, 'package-lock.json'), '{}');

      // Should either throw or return minimal structure
      try {
        const result = await LockfileParser.parse(testDir);
        expect(result).toBeDefined();
      } catch (error) {
        expect(error).toBeDefined();
      }
    });
  });

  describe('License normalization', () => {
    it('should handle missing license field', async () => {
      const lockfile = {
        name: 'test-project',
        version: '1.0.0',
        lockfileVersion: 2,
        packages: {
          '': {
            name: 'test-project',
            version: '1.0.0',
            dependencies: {
              'unlicensed-pkg': '^1.0.0',
            },
          },
          'node_modules/unlicensed-pkg': {
            version: '1.0.0',
            // No license field
          },
        },
      };

      fs.writeFileSync(
        path.join(testDir, 'package-lock.json'),
        JSON.stringify(lockfile)
      );

      const result = await LockfileParser.parse(testDir);

      // Should default to UNKNOWN or handle gracefully
      const pkg = result.children.find((c) => c.name === 'unlicensed-pkg');
      if (pkg) {
        // Either UNKNOWN or undefined is acceptable
        expect(['UNKNOWN', undefined]).toContain(pkg.license);
      }
    });
  });
});

